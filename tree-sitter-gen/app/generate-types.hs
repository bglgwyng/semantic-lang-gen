{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}
{-# LANGUAGE CPP #-}

import AST.GenerateSyntax
-- import qualified Bazel.Runfiles as Bazel
import Control.Lens (Traversal', mapped, (%~))
import Control.Monad
import Data.Foldable
import Data.Generics.Product.Typed (typed)
import Data.Maybe
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.IO as T
import Foreign
import GHC.Generics (Generic)
import Language.Haskell.TH hiding (JavaScript)
import Language.Haskell.TH.Lens
import NeatInterpolation
-- import qualified Options.Generic as Opt
import Source.Language
import System.FilePath
import System.Directory
import System.Exit
import System.IO
import System.Process
import Text.Printf
import qualified TreeSitter.Language as TreeSitter.Language
import qualified TreeSitter.Go as Go (tree_sitter_go)
import System.Environment (getArgs)


-- As a special case, you can pass
data Config = Config {language :: Text, rootdir :: FilePath}
  deriving stock (Show, Generic)
  -- deriving anyclass (Opt.ParseRecord)

-- There are a few cases where the output emitted by TH's 'pprint' doesn't
-- create entirely valid Haskell syntax, because sometimes we get
-- a qualified name on the LHS of a typeclass declaration, which Haskell
-- doesn't like at all. I haven't figured out quite why we get this qualified
-- name, but for now the easiest thing to do is some nested updates with lens.
adjust :: Dec -> Dec
adjust = _InstanceD . typed . mapped %~ (values %~ truncate) . (functions %~ truncate)
  where
    -- Need to handle functions with no arguments, which are parsed as ValD entities,
    -- as well as those with arguments, which are FunD.
    values, functions :: Traversal' Dec Name
    values = _ValD . typed . _VarP
    functions = _FunD . typed

    truncate :: Name -> Name
    truncate = mkName . nameBase


parserForLanguage :: Text -> Ptr TreeSitter.Language.Language
parserForLanguage = \case
  _ -> Go.tree_sitter_go

emit :: FilePath -> Text -> IO ()
emit root language = do
  path <- getArgs >>= \case
    (p:_) -> pure p
    _ -> die "Expected path argument"
  let languageHack = language
  
    --  pathForLanguage rf lang
  decls <- T.pack . pprint . fmap adjust <$> astDeclarationsIO (parserForLanguage language) path

  let programText =
        [trimming|
-- Language definition for $language, generated by ast-generate. Do not edit!
{-# LANGUAGE CPP #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE QuantifiedConstraints #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}

module Language.$language.AST (module Language.$language.AST) where

import qualified AST.Parse
import qualified AST.Token
import qualified AST.Traversable1.Class
import qualified AST.Unmarshal
import qualified Data.Foldable
import qualified Data.List as Data.OldList
import qualified Data.Maybe as GHC.Maybe
import qualified Data.Text.Internal
import qualified Data.Traversable
import qualified GHC.Base
import qualified GHC.Generics
import qualified GHC.Records
import qualified GHC.Show
import qualified Prelude as GHC.Classes
import qualified TreeSitter.Node

debugSymbolNames :: [GHC.Base.String]
debugSymbolNames = debugSymbolNames_0

$decls
  |]
  hasOrmolu <- findExecutable "ormolu"
  if isNothing hasOrmolu
    then do
      T.putStrLn programText
      hPutStrLn stderr "generate-ast: No `ormolu` executable found, output will look janky."
    else do
      (path, tf) <- openTempFile "/tmp" "generated.hs"
      T.hPutStrLn tf programText
      hClose tf
      callProcess "ormolu" ["--mode", "inplace", path]

main :: IO ()
main = do
  args <- getArgs
  let lang = head args
  let root = "."
  
  emit root "go"
