-- Language definition for Arith, generated by ast-generate. Do not edit!
{-# LANGUAGE CPP #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE QuantifiedConstraints #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}

module Language.Arith.AST (module Language.Arith.AST) where

import qualified AST.Parse
import qualified AST.Token
import qualified AST.Traversable1.Class
import qualified AST.Unmarshal
import qualified Data.Foldable
import qualified Data.List as Data.OldList
import qualified Data.Maybe as GHC.Maybe
import qualified Data.Text.Internal
import qualified Data.Traversable
import qualified GHC.Base
import qualified GHC.Generics
import qualified GHC.Records
import qualified GHC.Show
import qualified Prelude as GHC.Classes
import qualified TreeSitter.Node

debugSymbolNames :: [GHC.Base.String]
debugSymbolNames = debugSymbolNames_0

debugSymbolNames_0 :: [GHC.Base.String]
debugSymbolNames_0 = ["_end",
                      "_*",
                      "_/",
                      "_%",
                      "_+",
                      "_-",
                      "_(",
                      "_)",
                      "identifier",
                      "number",
                      "source_file",
                      "expression",
                      "binary_expression",
                      "unary_expression",
                      "parenthesized_expression",
                      "__expression"]
data BinaryExpression a
    = BinaryExpression {ann :: a,
                        right :: (AST.Parse.Err (((BinaryExpression GHC.Generics.:+: Identifier) GHC.Generics.:+: (Number GHC.Generics.:+: (ParenthesizedExpression GHC.Generics.:+: UnaryExpression))) a)),
                        operator :: (AST.Parse.Err (((AnonymousPercent GHC.Generics.:+: AnonymousStar) GHC.Generics.:+: (AnonymousPlus GHC.Generics.:+: (AnonymousMinus GHC.Generics.:+: AnonymousSlash))) a)),
                        left :: (AST.Parse.Err (((BinaryExpression GHC.Generics.:+: Identifier) GHC.Generics.:+: (Number GHC.Generics.:+: (ParenthesizedExpression GHC.Generics.:+: UnaryExpression))) a))}
    deriving stock (GHC.Generics.Generic, GHC.Generics.Generic1)
    deriving anyclass (AST.Traversable1.Class.Traversable1 Data.Foldable.Foldable)
    deriving anyclass (AST.Traversable1.Class.Traversable1 Data.Traversable.Traversable)
    deriving anyclass (AST.Traversable1.Class.Traversable1 GHC.Base.Functor)
instance AST.Unmarshal.SymbolMatching BinaryExpression
    where {matchedSymbols _ = [12];
           showFailure _ node_1 = "expected " GHC.Base.<> ("binary_expression" GHC.Base.<> (" but got " GHC.Base.<> (if TreeSitter.Node.nodeSymbol node_1 GHC.Classes.== 65535
                                                                                                                      then "ERROR"
                                                                                                                      else Data.OldList.genericIndex debugSymbolNames (TreeSitter.Node.nodeSymbol node_1) GHC.Base.<> (" [" GHC.Base.<> (GHC.Show.show r1_2 GHC.Base.<> (", " GHC.Base.<> (GHC.Show.show c1_3 GHC.Base.<> ("] -" GHC.Base.<> (" [" GHC.Base.<> (GHC.Show.show r2_4 GHC.Base.<> (", " GHC.Base.<> (GHC.Show.show c2_5 GHC.Base.<> "]"))))))))))))
                           where {TreeSitter.Node.TSPoint r1_2
                                                          c1_3 = TreeSitter.Node.nodeStartPoint node_1;
                                  TreeSitter.Node.TSPoint r2_4
                                                          c2_5 = TreeSitter.Node.nodeEndPoint node_1}}
deriving instance GHC.Classes.Eq a_6 => GHC.Classes.Eq (BinaryExpression a_6)
deriving instance GHC.Classes.Ord a_7 => GHC.Classes.Ord (BinaryExpression a_7)
deriving instance GHC.Show.Show a_8 => GHC.Show.Show (BinaryExpression a_8)
instance AST.Unmarshal.Unmarshal BinaryExpression
instance Data.Foldable.Foldable BinaryExpression
    where {foldMap = AST.Traversable1.Class.foldMapDefault1}
instance GHC.Base.Functor BinaryExpression
    where {fmap = AST.Traversable1.Class.fmapDefault1}
instance Data.Traversable.Traversable BinaryExpression
    where {traverse = AST.Traversable1.Class.traverseDefault1}
data Expression a
    = Expression {ann :: a,
                  extraChildren :: (AST.Parse.Err (((BinaryExpression GHC.Generics.:+: Identifier) GHC.Generics.:+: (Number GHC.Generics.:+: (ParenthesizedExpression GHC.Generics.:+: UnaryExpression))) a))}
    deriving stock (GHC.Generics.Generic, GHC.Generics.Generic1)
    deriving anyclass (AST.Traversable1.Class.Traversable1 Data.Foldable.Foldable)
    deriving anyclass (AST.Traversable1.Class.Traversable1 Data.Traversable.Traversable)
    deriving anyclass (AST.Traversable1.Class.Traversable1 GHC.Base.Functor)
instance AST.Unmarshal.SymbolMatching Expression
    where {matchedSymbols _ = [11];
           showFailure _ node_9 = "expected " GHC.Base.<> ("expression" GHC.Base.<> (" but got " GHC.Base.<> (if TreeSitter.Node.nodeSymbol node_9 GHC.Classes.== 65535
                                                                                                               then "ERROR"
                                                                                                               else Data.OldList.genericIndex debugSymbolNames (TreeSitter.Node.nodeSymbol node_9) GHC.Base.<> (" [" GHC.Base.<> (GHC.Show.show r1_10 GHC.Base.<> (", " GHC.Base.<> (GHC.Show.show c1_11 GHC.Base.<> ("] -" GHC.Base.<> (" [" GHC.Base.<> (GHC.Show.show r2_12 GHC.Base.<> (", " GHC.Base.<> (GHC.Show.show c2_13 GHC.Base.<> "]"))))))))))))
                           where {TreeSitter.Node.TSPoint r1_10
                                                          c1_11 = TreeSitter.Node.nodeStartPoint node_9;
                                  TreeSitter.Node.TSPoint r2_12
                                                          c2_13 = TreeSitter.Node.nodeEndPoint node_9}}
deriving instance GHC.Classes.Eq a_14 => GHC.Classes.Eq (Expression a_14)
deriving instance GHC.Classes.Ord a_15 => GHC.Classes.Ord (Expression a_15)
deriving instance GHC.Show.Show a_16 => GHC.Show.Show (Expression a_16)
instance AST.Unmarshal.Unmarshal Expression
instance Data.Foldable.Foldable Expression
    where {foldMap = AST.Traversable1.Class.foldMapDefault1}
instance GHC.Base.Functor Expression
    where {fmap = AST.Traversable1.Class.fmapDefault1}
instance Data.Traversable.Traversable Expression
    where {traverse = AST.Traversable1.Class.traverseDefault1}
data ParenthesizedExpression a
    = ParenthesizedExpression {ann :: a,
                               extraChildren :: (AST.Parse.Err (Expression a))}
    deriving stock (GHC.Generics.Generic, GHC.Generics.Generic1)
    deriving anyclass (AST.Traversable1.Class.Traversable1 Data.Foldable.Foldable)
    deriving anyclass (AST.Traversable1.Class.Traversable1 Data.Traversable.Traversable)
    deriving anyclass (AST.Traversable1.Class.Traversable1 GHC.Base.Functor)
instance AST.Unmarshal.SymbolMatching ParenthesizedExpression
    where {matchedSymbols _ = [14];
           showFailure _ node_17 = "expected " GHC.Base.<> ("parenthesized_expression" GHC.Base.<> (" but got " GHC.Base.<> (if TreeSitter.Node.nodeSymbol node_17 GHC.Classes.== 65535
                                                                                                                              then "ERROR"
                                                                                                                              else Data.OldList.genericIndex debugSymbolNames (TreeSitter.Node.nodeSymbol node_17) GHC.Base.<> (" [" GHC.Base.<> (GHC.Show.show r1_18 GHC.Base.<> (", " GHC.Base.<> (GHC.Show.show c1_19 GHC.Base.<> ("] -" GHC.Base.<> (" [" GHC.Base.<> (GHC.Show.show r2_20 GHC.Base.<> (", " GHC.Base.<> (GHC.Show.show c2_21 GHC.Base.<> "]"))))))))))))
                           where {TreeSitter.Node.TSPoint r1_18
                                                          c1_19 = TreeSitter.Node.nodeStartPoint node_17;
                                  TreeSitter.Node.TSPoint r2_20
                                                          c2_21 = TreeSitter.Node.nodeEndPoint node_17}}
deriving instance GHC.Classes.Eq a_22 => GHC.Classes.Eq (ParenthesizedExpression a_22)
deriving instance GHC.Classes.Ord a_23 => GHC.Classes.Ord (ParenthesizedExpression a_23)
deriving instance GHC.Show.Show a_24 => GHC.Show.Show (ParenthesizedExpression a_24)
instance AST.Unmarshal.Unmarshal ParenthesizedExpression
instance Data.Foldable.Foldable ParenthesizedExpression
    where {foldMap = AST.Traversable1.Class.foldMapDefault1}
instance GHC.Base.Functor ParenthesizedExpression
    where {fmap = AST.Traversable1.Class.fmapDefault1}
instance Data.Traversable.Traversable ParenthesizedExpression
    where {traverse = AST.Traversable1.Class.traverseDefault1}
data SourceFile a
    = SourceFile {ann :: a,
                  extraChildren :: (AST.Parse.Err (Expression a))}
    deriving stock (GHC.Generics.Generic, GHC.Generics.Generic1)
    deriving anyclass (AST.Traversable1.Class.Traversable1 Data.Foldable.Foldable)
    deriving anyclass (AST.Traversable1.Class.Traversable1 Data.Traversable.Traversable)
    deriving anyclass (AST.Traversable1.Class.Traversable1 GHC.Base.Functor)
instance AST.Unmarshal.SymbolMatching SourceFile
    where {matchedSymbols _ = [10];
           showFailure _ node_25 = "expected " GHC.Base.<> ("source_file" GHC.Base.<> (" but got " GHC.Base.<> (if TreeSitter.Node.nodeSymbol node_25 GHC.Classes.== 65535
                                                                                                                 then "ERROR"
                                                                                                                 else Data.OldList.genericIndex debugSymbolNames (TreeSitter.Node.nodeSymbol node_25) GHC.Base.<> (" [" GHC.Base.<> (GHC.Show.show r1_26 GHC.Base.<> (", " GHC.Base.<> (GHC.Show.show c1_27 GHC.Base.<> ("] -" GHC.Base.<> (" [" GHC.Base.<> (GHC.Show.show r2_28 GHC.Base.<> (", " GHC.Base.<> (GHC.Show.show c2_29 GHC.Base.<> "]"))))))))))))
                           where {TreeSitter.Node.TSPoint r1_26
                                                          c1_27 = TreeSitter.Node.nodeStartPoint node_25;
                                  TreeSitter.Node.TSPoint r2_28
                                                          c2_29 = TreeSitter.Node.nodeEndPoint node_25}}
deriving instance GHC.Classes.Eq a_30 => GHC.Classes.Eq (SourceFile a_30)
deriving instance GHC.Classes.Ord a_31 => GHC.Classes.Ord (SourceFile a_31)
deriving instance GHC.Show.Show a_32 => GHC.Show.Show (SourceFile a_32)
instance AST.Unmarshal.Unmarshal SourceFile
instance Data.Foldable.Foldable SourceFile
    where {foldMap = AST.Traversable1.Class.foldMapDefault1}
instance GHC.Base.Functor SourceFile
    where {fmap = AST.Traversable1.Class.fmapDefault1}
instance Data.Traversable.Traversable SourceFile
    where {traverse = AST.Traversable1.Class.traverseDefault1}
data UnaryExpression a
    = UnaryExpression {ann :: a,
                       operand :: (AST.Parse.Err (((BinaryExpression GHC.Generics.:+: Identifier) GHC.Generics.:+: (Number GHC.Generics.:+: (ParenthesizedExpression GHC.Generics.:+: UnaryExpression))) a)),
                       operator :: (AST.Parse.Err ((AnonymousPlus GHC.Generics.:+: AnonymousMinus) a))}
    deriving stock (GHC.Generics.Generic, GHC.Generics.Generic1)
    deriving anyclass (AST.Traversable1.Class.Traversable1 Data.Foldable.Foldable)
    deriving anyclass (AST.Traversable1.Class.Traversable1 Data.Traversable.Traversable)
    deriving anyclass (AST.Traversable1.Class.Traversable1 GHC.Base.Functor)
instance AST.Unmarshal.SymbolMatching UnaryExpression
    where {matchedSymbols _ = [13];
           showFailure _ node_33 = "expected " GHC.Base.<> ("unary_expression" GHC.Base.<> (" but got " GHC.Base.<> (if TreeSitter.Node.nodeSymbol node_33 GHC.Classes.== 65535
                                                                                                                      then "ERROR"
                                                                                                                      else Data.OldList.genericIndex debugSymbolNames (TreeSitter.Node.nodeSymbol node_33) GHC.Base.<> (" [" GHC.Base.<> (GHC.Show.show r1_34 GHC.Base.<> (", " GHC.Base.<> (GHC.Show.show c1_35 GHC.Base.<> ("] -" GHC.Base.<> (" [" GHC.Base.<> (GHC.Show.show r2_36 GHC.Base.<> (", " GHC.Base.<> (GHC.Show.show c2_37 GHC.Base.<> "]"))))))))))))
                           where {TreeSitter.Node.TSPoint r1_34
                                                          c1_35 = TreeSitter.Node.nodeStartPoint node_33;
                                  TreeSitter.Node.TSPoint r2_36
                                                          c2_37 = TreeSitter.Node.nodeEndPoint node_33}}
deriving instance GHC.Classes.Eq a_38 => GHC.Classes.Eq (UnaryExpression a_38)
deriving instance GHC.Classes.Ord a_39 => GHC.Classes.Ord (UnaryExpression a_39)
deriving instance GHC.Show.Show a_40 => GHC.Show.Show (UnaryExpression a_40)
instance AST.Unmarshal.Unmarshal UnaryExpression
instance Data.Foldable.Foldable UnaryExpression
    where {foldMap = AST.Traversable1.Class.foldMapDefault1}
instance GHC.Base.Functor UnaryExpression
    where {fmap = AST.Traversable1.Class.fmapDefault1}
instance Data.Traversable.Traversable UnaryExpression
    where {traverse = AST.Traversable1.Class.traverseDefault1}
type AnonymousPercent = AST.Token.Token "%" 3
type AnonymousLParen = AST.Token.Token "(" 6
type AnonymousRParen = AST.Token.Token ")" 7
type AnonymousStar = AST.Token.Token "*" 1
type AnonymousPlus = AST.Token.Token "+" 4
type AnonymousMinus = AST.Token.Token "-" 5
type AnonymousSlash = AST.Token.Token "/" 2
data Identifier a
    = Identifier {ann :: a, text :: Data.Text.Internal.Text}
    deriving stock (GHC.Generics.Generic, GHC.Generics.Generic1)
    deriving anyclass (AST.Traversable1.Class.Traversable1 Data.Foldable.Foldable)
    deriving anyclass (AST.Traversable1.Class.Traversable1 Data.Traversable.Traversable)
    deriving anyclass (AST.Traversable1.Class.Traversable1 GHC.Base.Functor)
instance AST.Unmarshal.SymbolMatching Identifier
    where {matchedSymbols _ = [8];
           showFailure _ node_41 = "expected " GHC.Base.<> ("identifier" GHC.Base.<> (" but got " GHC.Base.<> (if TreeSitter.Node.nodeSymbol node_41 GHC.Classes.== 65535
                                                                                                                then "ERROR"
                                                                                                                else Data.OldList.genericIndex debugSymbolNames (TreeSitter.Node.nodeSymbol node_41) GHC.Base.<> (" [" GHC.Base.<> (GHC.Show.show r1_42 GHC.Base.<> (", " GHC.Base.<> (GHC.Show.show c1_43 GHC.Base.<> ("] -" GHC.Base.<> (" [" GHC.Base.<> (GHC.Show.show r2_44 GHC.Base.<> (", " GHC.Base.<> (GHC.Show.show c2_45 GHC.Base.<> "]"))))))))))))
                           where {TreeSitter.Node.TSPoint r1_42
                                                          c1_43 = TreeSitter.Node.nodeStartPoint node_41;
                                  TreeSitter.Node.TSPoint r2_44
                                                          c2_45 = TreeSitter.Node.nodeEndPoint node_41}}
deriving instance GHC.Classes.Eq a_46 => GHC.Classes.Eq (Identifier a_46)
deriving instance GHC.Classes.Ord a_47 => GHC.Classes.Ord (Identifier a_47)
deriving instance GHC.Show.Show a_48 => GHC.Show.Show (Identifier a_48)
instance AST.Unmarshal.Unmarshal Identifier
instance Data.Foldable.Foldable Identifier
    where {foldMap = AST.Traversable1.Class.foldMapDefault1}
instance GHC.Base.Functor Identifier
    where {fmap = AST.Traversable1.Class.fmapDefault1}
instance Data.Traversable.Traversable Identifier
    where {traverse = AST.Traversable1.Class.traverseDefault1}
data Number a
    = Number {ann :: a, text :: Data.Text.Internal.Text}
    deriving stock (GHC.Generics.Generic, GHC.Generics.Generic1)
    deriving anyclass (AST.Traversable1.Class.Traversable1 Data.Foldable.Foldable)
    deriving anyclass (AST.Traversable1.Class.Traversable1 Data.Traversable.Traversable)
    deriving anyclass (AST.Traversable1.Class.Traversable1 GHC.Base.Functor)
instance AST.Unmarshal.SymbolMatching Number
    where {matchedSymbols _ = [9];
           showFailure _ node_49 = "expected " GHC.Base.<> ("number" GHC.Base.<> (" but got " GHC.Base.<> (if TreeSitter.Node.nodeSymbol node_49 GHC.Classes.== 65535
                                                                                                            then "ERROR"
                                                                                                            else Data.OldList.genericIndex debugSymbolNames (TreeSitter.Node.nodeSymbol node_49) GHC.Base.<> (" [" GHC.Base.<> (GHC.Show.show r1_50 GHC.Base.<> (", " GHC.Base.<> (GHC.Show.show c1_51 GHC.Base.<> ("] -" GHC.Base.<> (" [" GHC.Base.<> (GHC.Show.show r2_52 GHC.Base.<> (", " GHC.Base.<> (GHC.Show.show c2_53 GHC.Base.<> "]"))))))))))))
                           where {TreeSitter.Node.TSPoint r1_50
                                                          c1_51 = TreeSitter.Node.nodeStartPoint node_49;
                                  TreeSitter.Node.TSPoint r2_52
                                                          c2_53 = TreeSitter.Node.nodeEndPoint node_49}}
deriving instance GHC.Classes.Eq a_54 => GHC.Classes.Eq (Number a_54)
deriving instance GHC.Classes.Ord a_55 => GHC.Classes.Ord (Number a_55)
deriving instance GHC.Show.Show a_56 => GHC.Show.Show (Number a_56)
instance AST.Unmarshal.Unmarshal Number
instance Data.Foldable.Foldable Number
    where {foldMap = AST.Traversable1.Class.foldMapDefault1}
instance GHC.Base.Functor Number
    where {fmap = AST.Traversable1.Class.fmapDefault1}
instance Data.Traversable.Traversable Number
    where {traverse = AST.Traversable1.Class.traverseDefault1}
